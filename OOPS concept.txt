									OOPS concepts
								----------------------

								
date : 29-02-16

							1. Data hiding
							2. Abstraction
							3. Encapsulation
							4. Tightly encapsulated class  // module 1 still here are security
							5. IS-A relationship
							6. Has-a relationship    //Theoretical concepts Still here
							7. Method signature  
							8. Overriding
							9. Overloading
							10. static control flow
							11. Instance control flow 
							12. constructors
							13. coupling
							14. cohesion
							15. Type casting
	
	1. Data hiding:
	----------------
		Outside person can't access our internal data directly or our internal data should not go out directly. This oop feature is nothing but Data hiding
		Example1
		After validation outside person can access our internal data. After providing proper username/password we can able to 

		access our gmail inbox information.
		Example2
		Eventhough we are valid customer of the bank we can able to access our account information and we can't access others account information
		By declaring data member(variable) as private we can achieve data hiding.
			public class Account{
			
				private double balance;
				
				public double getBalance(){
					//validation
					return balance;
					
				
				}
			}
		The main advantage of data hiding is security.
		Note: It is highly recommended to declare data member(variable) as private
	
	2. Abstraction
	---------------
		Hiding internal implementation and just highlight the set of services what we are offering is concept of abstraction.
		
		Example
		--------
		Through bank atm gui screen bank people are highlighting the set of services what they are offering without highlighting internal implementation 
		
		The major advantages of abstraction are
			1. We can achieve security because we are not highlighting our internal implementation
			2. Without affecting outside person we can able to perform any type of changes in our internal system and hence
			   enhancement will become easy
			3. It improves maintainability of the application
			4. It improves easiness to use of system
		By using interfaces, and abstract classes we can implement abstraction.
	
	3. Encapsulation
	-----------------
		The process of binding data and corresponding methods into a single unit is nothing but Encapsulation.
		
		Example: 	Class Student{
					
					data Members + methods(Behavior)
						
					}
		If any component follows data hiding and abstaction such type of component is said to be encapsulted component.
				Encapuslation = data hiding + Abstraction
		
		The main advantages of Encapsulation are
			1. We can achieve security
			2. Enhancement will become easy
			3. It improves maintainability of the application
		
		The main disadvantage of Encapsulation is it increases length of code and slows down execution
	
	4. Tightly Encapsulated Class
	-------------------------------
		A class is said to be tightly encapsulated if and only is each and every variable declared as private whether class contains corresponding getter and setter methods or not and whether these methods are declared as public or not
		These things we are not required to check.
		
			public Class Account{
				
				private double balance;
				
				public double getBalance(){
					///
					return double;
				}
			
	** Which of the following classes are tightly encapsulated?
			class A{						class B extends A{							Class C extends A{
				private int x = 10;				int y = 10;									private int z =10;
				
			}								}												}
			Yes									No											Yes
			
			
		2.	class A{						class B extends A{							Class C extends B{
			int x = 10;					 	private int y = 10;							 private int z =10;
				
			}								}												}
			No									No											No
				
		 Note: If the parent class is not tightly encapsulated then no child class is tightly encapsulated.
	
Dateate : 02-03-16

	Is-A relationship:
	------------------
		It is also known as inheritance.
		The main advantage of Is-a relationship is code reusablity. 
		By using extends keyword we can implement is-a relationship
		
		Example
		---------
		
		Class P{
			public void m1(){
				sop("Parent");
			}
		}
		
		
		Class C extends P{
			public void m2(){
				sop("Child");
			}
		}
		Class Test{
			public static void main(String[] args){
			(1)	P p =new P();
				p.m1();
				p.m2() // compile time error: cannot find symbol; method m2() location: Class P
				
			(2)	C c = new C();
				c.m1();
				c.m2();
				
			(3)	P p1 = new C();
				p1.m1();
				p1.m2(); // compile time error: cannot find symbol; method m2() location: Class P
				
			(4)	C c1 =new P(); // compile time error: incompatible types found P required C
				
			
			}
		
		}
		
		Conclusions:
		------------
		 Whatever methods parent has by default available to the child and hence on the child reference we can call both
		 parent and child class methods
		 Whatever methods child has by default not available to the parent and hence on the parent reference we can't call
		 child specific methods.
		 Parent reference can be used to hold child object but using that reference we can't call child specific methods but
		 we can call the methods present in parent class
		 Parent refernce can be used to hold child object but child reference can't be used to hold parent object
		 
		 Total java api is implemented based on inheritance concept
		 The most common methods which are applicable for any java object are defined in Object class and hence Every class in
		 Java is the child class of Object either directly or indirectly. So that Object class methods by default avaialble to
		 every java class without rewriting. Due to this Object class access root for all Java classes
		 Throwable class defines the most common methods which are required for every Exception and Error classes and hence
		 this Class acts as root for Java Exception hirearchy
		 
		 A java class cannot extend more than one class at a time. hence java wont provide support for multiple inheritance in classes
			Class A extends B,C{ //invalid will get compile errors
			
			}
		 
		 Note: If our class does not extend any other class then only our class is direct child class of Object
		 
		 Class A{ 								Object
												  |
												  |	
		 }										  A
		 If our class extends any other class then our class is indirect child class of Object.
		 
		 Class A extends B{						Object
												  |
												  |
												  B
												  |
												  |
		}										  A
											Multi-level Inheritance
							
		Either directly or indirectly java provide support for inheritance w.r.t classes
		
		Why Java won't provide support for multiple inheritance?
			There may be a chance of ambiguoty problem. Hence java won't provide support for multiple inheritances.
						
							P1--> m1()					p2-->m1()
							|	extends						|
							----------------------------------
										|
										C uses m1();
									Ambiguoty problem
			But interface can extend any number of simultaneously. Hence Java provide support for Multiple inheritance w.r.t interfaces
			
				interface A{			interface B{					
				
				}						}								
				
						interface C extends A,B{
						}
		Why ambiguoty problem wont be there in interfaces?
		
				interface	P1--> m1()					p22-->m1() interface
							|	extends						|
							----------------------------------
										|
							interface	C uses m1();
										|
										| implements
										|
									Implementor class
			Eventhough multiple method declarations are available but implementation is unique. Hence there is no chance of ambiguoty problem in interfaces.
			
		Note: Strictly speaking through interfaces we wont get any inheritance.
		
		Cyclic Inheritance
		------------------
			Cyclic inheritance is not allowed in java. ofcourse it is not required.
			Example
				Class A extends A{ // A is the child of A
								// compile time error cyclic inheritance
				}
			
			
				Class A extends B{ // A is the child of B
				
				}
								// compile time error cyclic inheritance
				Class B extends A{ // B is the child of A
				
				}
			
	Date 10-03-2016
	
	Has-a relationship
	------------------
		Has-a relationship is also known as composition or aggregation.
		There is no specific keyword to implement Has-a relation but most of the times we are depending on new keyword
		The main advantage of Has-a relationship is reusability of the code
		
		Example:
		
			Class Car{
				Engine e = new Engine(); // Car has-a engine reference
				
			}
			Class Engine{
				....
				....
			}
		
		Difference between composition and aggregation
		----------------------------------------------
			Without existing container object if there is no chance of existing contained objects then container and contained objects are strongly associated and this strong association is nothing but Composition
			
			University consists of several departments. without existing university there is no chance of existing department. Hence university and department are strongly associated and this strong association is nothing but composition.
			
			Aggregation
			-----------
			Without existing container object if there is a chance of existing contained objects then container and contained objects are weekly associated and this week association is nothing but Aggregation
			
			Department consists of several professors. Without existing department there may be chance of existing professor objects. Hence Department and professor objects are weekly associated and this week association is nothing but Aggregation.
			
			In composition container object holds directly contained objects where as in aggregation container object holds just references of contained objects
			
		Is-a vs has-a
		-------------
			If we want to total functionality of a class automatically then we should go for is-a relationship
			Ex: Person class total functioanlity required for Student class. Student is a person
			If we want part of the functioanlity then we should go for has-a relationship
			Ex: Test clfass contains 100 methods. we required one method then create instance of Test class Use those methods
	
		Method signature
		----------------
			In java method signature consists of method names followed by argument types
				public static int m1(int i,float f); //m1(int,fload) are method signatures
			return type is not a part of method signature in Java

	Overloading
	-----------
		Two methods are said to be overloaded if and only if both methods having same name and different argument types
		In C language method overloading concept is not available. Hence we can't declare multiple methods with same name but different argument types. 
		If there is change in argument type compulsory we should go for new method name which increases complexity of programming
		Having overloading concept in java reduces complexity of programming
		
		*** In overloading method resoultion always takes care by compiler based on reference type Hence overloading is also considered as compile time polymorphism or static polymorphism or early binding.
			// method resolution means which method has to execute . that decision taken by compiler
		
			
	Date: 12th March 2016
	---------------------
	case 1: 
		Automatic promotion in overloading while resolving overloaded methods if exact matched method is not available then we won't get any compile time error immediately.
		First it will promote argument to the next level and check whether matched method is available or not. If matched method is available then it will be considered If the matched method is not available then compiler promotes argument once again to the next level. This process will be continued until all possible promotions still if the matched method is not available then we will get compile time error
		
		The following are all possible promotions in overloading
		
		byte--> short-->int-->long-->float-->double
						^
						|
					char
		This process is called automatic promotion in overloading
		
			Class Test{
				public void m1(int i){
					sop("int arg method");
				
				}
				public void m1(float f){
					sop("float arg method");
				
				}
				
				public static void main(String[] args){
					Test t = new Test();
					t.m1(10);
					t.m1(10.5f);
					t.m1('a');
					t.m1(10l);
					t.m1(10.5) //compile time error. Cannot find symbol method m1(double) location Class Test
				}
			}
		
	Case 2:
		
		Class Test{
				public void m1(Object obj){
					sop("Object version");
				
				}
				public void m1(String str){
					sop("String version");
				
				}
				
				public static void main(String[] args){
					Test t = new Test();
					t.m1(new Object()); // Object version
					t.m1("Kranti");// String version
					t.m1(null); // String version
				}
			}
		
Date: 17th March 2016
-----------------------
	Note: While resolving overloaded methods compiler will always gives precedence for child type argument when compared with parent type argument
	
	Case 3:
		Class Test{
				public void m1(StringBuffer sb){
					sop("StringBuffer version");
				
				}
				public void m1(String str){
					sop("String version");
				
				}
				
				public static void main(String[] args){
					Test t = new Test();
					t.m1(new StringBuffer("Kranti")); // StringBuffer version
					t.m1("Kranti");// String version
					t.m1(null); // compile time error : reference to m1() is ambiguous 
				}
			}
								Object
								  |
								  |
							-------------
							|			|
						String		StringBuffer // both objects are same level
	
	Case 4: 
			
			Class Test{
				public void m1(int i, float f){
					sop("int float version");
				
				}
				public void m1(float f,int i){
					sop("float int version");
				
				}
				
				public static void main(String[] args){
					Test t = new Test();
					t.m1(10,10.5f); // int float version
					t.m1(10.5f,19);// float int version
					t.m1(10,10); // compile time error : reference to m1() is ambiguous 
					t.m1(10.5f,10.5f);// compile time error : Cannot find symbol to m1(float,float)
				}
			}
	
	Case 5:
	
		Class Test{
				public void m1(int x){
					sop("General method");
				
				}
				public void m1(int .. x){
					sop("var args method");
				
				}
				
				public static void main(String[] args){
					Test t = new Test();
					t.m1(); // var arg method
					t.m1(10,10,10);// var arg method
					t.m1(10); // General method
					
				}
			}
			
		In general var arg method will get least priority i.e., if no other method matched then only var arg method will get chance. It is exactly same as default case inside switch
		
		
		Class Animal{
		};
		Class Monkey extends Animal{}
		
		
		
		Class Test{
				public void m1(Animal a){
					sop("Animal Version");
				
				}
				public void m1(Monkey m){
					sop("Monkey Version");
				
				}
				
				public static void main(String[] args){
					Test t = new Test();
					Animal a = new Animal();
					
					t.m1(a); // Animal Version
					Monkey m = new Monkey();
					t.m1(m);// Monkey version
					Animal a1 = new Monkey()
					t.m1(a1); // Animal version
					
				}
			}
	NOte: In overloading method resolution(executing method) always takes care by compiler based on reference type. In overloading run time object wont play any role
	
	
	Overriding
	------------
		Whatever methods parent has by default available to the child through inheritance if child class not satisfied with parent class implementation then child is allowed to redefine the method based on its requirement. This process is called Overriding
	
	
		The parent class method which is overridden is called overridden method and the child class method which is overriding is called overriding method.
		
			Class P{
			
				public void property(){
					sop("CASH | LAND | GOLD");
				}
			
				public void marry(){		-------------------------- overridden
					sop("x");					|
				}								|
												|
												|	--> Overriding
			}									|
		Class C extends P{						|
												|
			public void marry(){			-------------------------------Overriding
				sop("y");
			}						
			
		
		
		}
		Class Test{
			public static void main(String[] args){
				P p = new P();                                                       
				p.marry() // x;
				C c = new C();
				c.marry();//y;
				P p = new C();
				p.marry();//y
				
				
			
			}
		
		
		}
		** In overriding method resoultion always takes care by JVM based on run time object and hence overriding is also consider as Runtime polymorphism or dynamic polymorphism or late binding
	
Date: 18th March 2016	
		Rules for overriding
		--------------------
		1. In overriding method names and argument types must be matched i.e., method signatures must be same
		2. In overriding return types must be same but this rule is applicable until 1.4 version only. From 1.5 version
		   onwards we can take covariant return types. According to this child class method return type need not be same as parent method return type. Its child type also allowed 
				Class P{
					public Object m1(){
					
							return null;
					}
				}
				Class C extends P{
					public String m1(){
													//It is invalid in 1.4 version but from 1.5 version onwards it is valid
						return null;
					}
				}
			
			Compile lower version of java javac -source versionName ClassName.java eg: javac -source 1.5 P.java
		
		Parent class 		Object				Number				String				double
		return type			  |					  |					  |					  |
							  |					  |					  |					  |
		Child class			String	or			Number OR			Object				int
		return type			Object				Integer
							(true)				(true)				(false)				(false)
			
			Covariant type concept is applicable only for object types but not for primitive types
		
		Parent class private methods not available to the child and hence overriding concept not applicable for private methods.
		Based on our requirement we can define exactly same private method in child class. it is valid but not overriding
			Class P{
				private void m1(){
				
				}
			}
			Class C extends P{
				private void m1(){
				
				
				}
			
			}
			This is valid but not overriding
		
		We can't override parent class final methods in child classes. If we are trying to override we will get compile time error
			Class P{
				public final void m1(){
				}
			
			}
			
			Class C extends P{
				public void m1(){
											// m1() in c cannot override m1() in p ovrriden m1() is final
				
				}
			}
		
		Parent class abstract methods we should override in child class to provide implementation.
		
			abstract class P{
				public abstract void m1();
			
			}
			Class C extends p{
			
				public void m1(){
				
					}
			}
		
		We can override non abstract method as abstract method 
			class P {
				public void m1(){
				}
				
			}
			abstract class C extends P{
				public abstract void m1();
			}
		The main advantage of this approach is we can stop the availablity of parent method implementation to the next
		level child classes
		
		In overriding the following modifiers wont keep any restruction. synchronized, native,strictfp
		
		Parent method 		final				non-final			abstract	synchronized		native		strictfp
							  |					  |					  |	|			|	  |			 |  |		  | |
							  |					  |					  |	|			|	  |			 |	|		  | |
		Child class			non final			final				non-abstract non synchronized	non native	non-strictfp
		return type									
							(false)				(true)				(true)				(true)       (true)			(true)
			
		
		While overriding we can't reduce scope of access modifier. but we can increase the scope
		
			Class P{
				public void m1(){
				}
			}
			Class C extends P{
				void m1(){			// m1() in C cannot override m1() in P. attempting to assign 
									weaker access privileges public 
				}
			
			}
			Access modifiers privileges private --> default --> protected --> public
		
		Parent method 		public				default				protected			private
							  |					  |					  |					  |
							  |					  |					  |					  |
		Child method		public				default OR			protected or		Overriding concept is not 
												protected or		public				applicable
												public
		
		
		
		If child class method throws any checked exception compulsory parent class method should throw same checked exception or its parent otherwise we will get compile time error but there are no restrictions for unchecked exceptions
		
		
		import java.io.*
		Class P{
			public void m1() throws IOException{
			}
		}
		Class C extends P{
			public void m1() throws EOFException,InterruptedException{
			}
		}
		//invalid m1() in c cannot override m1() in p; overriden method does not throw java.lang.InterruptedException
		
		
		case 1:
		Parent: public void m1() throws Exception
		Child: public void m1(); //valid
		
		case 2:
		Parent: public void m1()
		Child: public void m1() throws Exception //invalid
		
		case 3:
		parent: public void m1() throws Exception
		child: public void m1() throws IOException //valid
		
		case 5:
		parent: public void m1() throws IOException
		child: public void m1() throws FileNotFoundException,EOFException //valid
		
		case 6:
		parent: public void m1() throws IOException
		child: public void m1() throws EOFException,InterruptedException //invalid
		
		case 7: 
		parent: public void m1() throws IOException
		child: public void m1() throws ArithmeticException,NullPointerException,ClassCastException //valid
		
		overriding with respect to static methods
		-----------------------------------------
		we can't override a static method as non-static otherwise we will get compile time error
			Class P{
				public static void m1() {
				}
			}
			Class C extends P{
				public void m1() {
				}
			}
			// compile time error: m1() in C cannot override m1() in p;overridden method is static
		
		similary we can't override a non-static methods as static 
			Class P{
				public  void m1() {
				}
			}
			Class C extends P{
				public static void m1() {
				}
			}
			// compile time error: m1() in C cannot override m1() in p;overridding method is static
		
		If both parent and child class methods are static then we won't get any compile time error. It seems overriding
		concept is applicable for static methods but it is not overriding and it is method hiding
			
			Class P{
				public static void m1() {
				}
			}													---- It is method hiding but not overriding		
			Class C extends P{
				public static void m1() {
				}
			}
		
		Method hiding
		-------------
			All rules of method hiding are exactly same as overriding except the following differences
			
							method hiding				|					overriding
			-------------------------------------------------------------------------------------------
				Both parent and child class method		|	Both parent and child class method should be
				should be static						|	non-static
														|
				compiler is responsible for method		|	JVM is always responsible for method resolution
				resolution based on reference type		|	based on runtime object
														|
				It is also known as compile time 		|	It is also known as runtime polymorphism or
				polymorphism or static polymorphism		|	dynamic polymorphism or late binding
				early binding							|
			---------------------------------------------------------------------------------------------
			
			
			Class P{
				public static void m1() {
					sop("parent")
				}
			}													
			Class C extends P{
				public static void m1() {
					sop("child")
				}
			}
			Class Test{
				public static void main(String[]args){
					P p = new P();
					p.m1();	//parent
					
					C c = new C();
					c.m1(); //child
					
					P p1 = new C();
					p1.m1(); //parent
				
				}
			
			}
			
	Date:20th March 2016
	---------------------
	Overriding w.r.t. var args method
	---------------------------------
		we can override var arg method with another var arg method only. If you are trying to override with normal method then
		it will become overloading but not overriding
		
			Class P{
			
				public void m1(int.. x){
					sop("Parent method");
				}
			
			}
											----------> It is overloading but not overriding
			Class C extends P{
				
				public void m1(int x){
					sop("child method")
				}
				
			}
			
			Class Test{
			
				public static void main(String[] args){
					P p = new P();
					p.m1(10); // Parent method
					
					C c = new C();
					c.m1(10) //Child method
					
					P p1 = new C();
					p1.m1(10); // Parent method
					
				}
			}
		In the above program if we replace child method with var arg method then it will become overriding. In this case output
		is 
			Parent Method
			Child Method
			child method
	
	Overriding w.r.t variables
	--------------------------
		Variable resolution always takes care by compiler based on reference type irrespective of whether the variable is 
		static or non-static(overriding concept applicable only for methods but not for variables)
			
			
			Class P{
			
				int x =888
			
			}
							
			Class C extends P{
				
				int x = 999;
				
			}
			
			Class Test{
			
				public static void main(String[] args){
					P p = new P();
					sop(p.x) // 888
					
					C c = new C();
					sop(c.x) // 999
					
					P p1 = new C();
					sop(p1.x) // 888
					
				}
			}
			
			p->non-static					p->static				p-> non-static				p->static
			c->non-static					c->non-static			c->static					c->static
				888								888						888							888
				999								999						999							999						
				888								888						888							888
	
	
	Differences between overloading and overriding
	----------------------------------------------
	
		Property					|		overloading					|	overriding
		--------------------------------------------------------------------------------------------------------------------
		1. method names				|	must be same					| must be same
		2. argument types			|	must be different 				| must be same(including order)
									|	(atleast order)					|
		3. method signatures		|	must be different				| must be same
		4. return types				|	No restrictions					| must be same until 1.4 version but
									|									| from 1.5 version onwards co variant return
									|									| types also allowed
		5. private,static,final		|	can be overloaded				| cannot be overriden
			methods					|									|
		6. Access modifiers			|	No restriction					| we can't reduce scope of access modifier
									|									| but we can increase the scope
		7. throws clause			| 	No restriction					| if child class method throws any checked exception
									|									| compulsory parent class method should throw the 
									|									| same checked exception or its parent but no 
									|									| restriction for unchecked exception
		8. Method resolution		|	always takes care by compiler	| Always takes care by JVM based on runtime object
									| 	based on reference type			|
		9.	It is also known as		|	compile time polymorphism		| Runtime polymorphism or dynamic polymorphism
									|	or static polymorphism			| or late binding
									|	or early binding				|
		---------------------------------------------------------------------------------------------------------------------
		
		Note: In overloading we have to check only method names (must be same) and argument types(must be different)
			  we are not required to check remaining like return types, access modifiers etc.,
			  In overriding every thing we have to check like method names, argument types, return types, access modifiers,
			  throws clause etc.,
		
		Consider the following method in parent class
				
				public void m1(int x) throws IOException
				
		In the child class which are the following methods we can take
			
			public void m1(int x) //overriding
			public static  int m1(Long l) //overloading
			public static void m1(int x) // not possible with overriding
			public void m1(int i)throws Excepiton // not possible with overriding
			public static abstract void m1(double d) // compile time error
				   ---------------
						|--> Illegal combination of modifiers
		
		Polymorphism
		------------
			One name but multiple forms is the concept of polymorphism
			ex1: method name  is the same but we can apply for different type of arguments(overloading)
						abs(int)
						abs(long)
						abs(float)
			
			ex2: method signature is same but in parent class one type of implementation and in the child class
				another type of implementation (overriding)
				class P{
				
					marry(){
						sop("subbalakshmi");
					}
				
				}
				class C extends P{
					marry(){
						sop("3sha|9tara|charmy");
					}
				}
			ex3: Usage of parent reference to hold child object is the concept of polymorphism
		
				List l = new ArrayList();
				List l = new LinkedList();
				List l = new Stack();
				List l = new Vector();
				
									Collection
										|
										|
									  List
										|
										|
						---------------------------------
						|			|					|
						ArrayList	LinkedList		  Vector
														|
														|
													  Stack
		
		Parent class can be used to hold child objects but by using that reference we can call only the methods available in
		Parent class and we can't call child specific methods
						
						P---> m1()
						|
						|
						C---> m2()
						
			P p = new C()
			p.m1();
			p.m2(); // compile time error cannot find symbol method m2() in Class P
		
		But by using child reference we can call both parent and child class methods
			C c = new C();
			c.m1();
			c.m2();
			
		When we should go for parent reference to hold child object?
			If we dont know exact runtime type of object then we should go for Parent reference. 
				Example: the first element present in the ArrayList can be any type.It may be Student obj, Customer obj
					String obj, StringBuffer obj.
					Hence the return type of get() is Object,which can hold any object.
						Object o = l.get(0);
							
							
						C c = new C()						|				P p= new C()
			------------------------------------------------------------------------------------------------------
				Ex : ArrayList al = new ArrayList()			|	Ex: List l = new ArrayList()
				1. we can use this approach if we know		|	we can use this approach if we dont know exact
					exact runtime type of object			|		runtime type of object
															|
				2. By using child reference we can call 	|	By using parent reference we can call only met
					both parent class and child class		|	available in Parent class and we can't call child
					methods(Advantage of this approach)		|	specific methods(Disadvantage of this approach)
															|
				3. We can use child reference to hold		|	We can use parent reference to hold any child class	
					only particular child class object		|	object (Advantage of this approach)
					(Disadvantage of this approach)			|
			---------------------------------------------------------------------------------------------------------			
			
			
			
												Encapsulation
													|
													| Security
													|
					polymorphism ----------------- OOPS ---------------- Inheritance
									flexibility				reusability	
									
									Three pillars of oops concepts
									-------------------------------
									
									
									Polymorphism
										|
										|
										|
						------------------------------------
						|									|
						|
				static polymorphism					Dynamic polymorphism
					or										or
				compiletime polymorphism			runtime polymorphism
					or										or
				early binding						late binding
				eg: overloading,method hiding		eg: overriding
			
		
		Coupling:
		----------
			The degree of dependency between the components is called coupling. If dependency is more then it is considered
			as tightly coupling and if dependency is less then it is considered as loosely coupling.
				Ex:
				
				class A{
					static int i = B.j;
				}
				
				
				class B{
					static int j = C.k;
				}
				
				
				class C{
					static int k = D.m1();
				}
				
				
				class D{
					static int m1(){
						return 10;
					}
				}
			
			The above components are said to be tightly coupled each other because dependency between the components is 
			more.
			Tightly coupling is not a good programming practice because it has several serious disadvantages
				1. Without effecting remaining components we can't modify any component and hence enhancement will become
					difficult
				2. It supresses reusability
				3. It reduces maintainability of the application
			Hence we have to maintain dependency between the components as less as possible i.e., loosly coupling is a good
			programming practice
			
		Cohesion
		---------
			For every component a clear well defined functionality is defined then that component is said to be follow
			High cohesion
			
					----------------				|login page|-------> | validate |	---> |inbox| --> ... -->...
					|  Login page	|				------------		 ------------		 --------
					|	validation	|				login .jsp			validate servlet	index.jsp
					|	index page	|
					|	reply page	|
					|	compose page|
					|	error page	|
					|		.		|							high cohesion
					|		.		|
					|		.		|
					-----------------
						low cohesion
			High cohesion is good programming practice because it has several advantages.
				1. Without effecting remaining components we can modify any component hence enhancement will become easy
				2. It promotes re-usability of the code(wherever validation is required we can reuse the same validate servlet)
					without rewriting
				3. It improves maintainability of the application
		Note: loosely coupling and high cohesion are good programming practices
		
	
	Object Type casting
	-------------------
		we can use parent reference to hold child object
			ex:  Object o = new String();
		we can use interface reference to hold implemented class Object
			ex: Runnable r = new Thread();
		
			
		class|interface name-->	A  b = (C)d --> reference variable name
		 reference variable name<--|	|--> class|interface name
		
		Mantra 1(Compile time checking 1):
			The type of 'd' and 'C' must have some relation either (Child to Parent or Parent to child or same type)
			otherwise we will get compile time error saying inconvertable types found d type required C
					Object o =new String('Durga');
					StringBuffer sb = (StringBuffer)o;
		
		Mantra 2(Compile time checking 2):
			'C' must be either same or derived type of 'A' otherwise we will get compile time error saying incompatible
			types found c required A
				ex1:Object o =new String('Durga');
					StringBuffer sb = (StringBuffer)o;
				
				ex1:	Object o =new String('Durga');
						StringBuffer sb = (String)o; //compile time error:incompatible types found java.lang.String requried
														java.lang.StringBuffer
		
		Mantra 3
		---------
				Runtime object type of 'd' must be either same or derived type of 'C' otherwise we will get runtime exception
				saying ClassCastException
				ex1:Object o =new String('Durga');
					StringBuffer sb = (StringBuffer)o; //runtime exception saying ClassCastException java.lang.String cannot
														be cast to java.lang.StringBuffer
				
				ex2: Object o =new String('Durga');
					 Object o1 = (String)o;
					 
					 
												Object
												  |
												  |
									-------------------------
									|						|
									|						|
									Base1					Base2
									|						|
								--------				---------	
								|		|				|		|								
								Der1	Der2			Der3	Der4
								
				Base2 b = new Der4();
				
				1. Object o =(Base2)b;  // valid 
				2. Object o =(Base1)b;	// compiletime error Incovertible types
				3. Object o =(Der3)b;	//Runtime exception: ClassCastException
				4. Base2 b1=(Base1)b;	// inconvertable types
				5. Base1 b1=(Der4)b;	// incompatible types
				6. Base1 b1 = (Der1)b;	//compiletime error: inconvertable types
			
		Strictly speaking through type casting we are not creating any new objects for the existing object we are providing
		another type of reference variable i.e., we are performing type casting but not object casting
			Example 1:
				String s = new String('Durga');	---
				Object o =(Object) s;			  |---> Object o =new String('Durga');

											String s -------|
															|	 |--------|	
															|----|	Durga |
															|    |--------|
											Object o--------|															
	
				
			Example 2:
					Object o =		|---Integer i = new Integer(10); --|
					new Integer(10)	|	Number n = (Number)i;		 --|--- Number n = new Integer(10);
									|---Object o =(Object)n;
											sop(i == n)//true
											sop(n==o) true
				
											integer i-------|
															|	 |--------|	
											Number n -------|----|	10	  |
															|    |--------|
											Object o--------|															
		
			Note: 					A
									|
									|
									B
									|
									|
									C
								C c = new C();
								B b = (B)c;  // B b = new C();
								A a =(A)((B)b); //A a = new C();
			
			Example 1
								P --> m1()
								|
								|
								C -->m2()
								
							C c = new C();
							c.m1(); // valid
							c.m2(); //valid
							((P)c).m1(); // P p = new C();//valid
							((P)c).m2()  //P p = new C() //invalid
		
			Example 2: 				A -->m1(){sop("A");}				
									|
									|
									B -->m1(){sop("B");}			
									|
									|
									C -->m1(){sop("C");}				
							
							C c = new C();
							c.m1(); //C
							((B)c).m1();//C
							(A((B)c).m1(); //C
							
				It is overriding and method resolution always based on runtime object
				
			Example 3: 				A -->static m1(){sop("A");}				
									|
									|
									B -->static m1(){sop("B");}			
									|
									|
									C -->static m1(){sop("C");}				
							
							C c = new C();
							c.m1(); //C
							((B)c).m1();//B
							(A((B)c).m1(); //A

				It is method hiding and method resolution always based on reference type
				
			Example 3: 				A -->int x = 777
									|
									|
									B -->int x = 888
									|
									|
									C -->int x = 999
							
							C c = new C();
							sop(x); //999
							((B)c).x;//888
							(A((B)c).x; //777
				variable resolution is always based on reference type but not based on runtime object
				
			
		static control flow;
		--------------------
			whenever we are executing a java class the following sequence of steps will be executed as the part of 
			static control flow
				1. Identification of static members from top to bottom (1 to 6)
				2. Execution of static variables assignments and static blocks from top to bottom (7 to 12)
				3. Execution of main method (13 to 15)
				
					class Base{
		i =0[RIWO](1)		static int i =10;  (7)
		j=0[RIWO](2)		static{
		i=10[RW];				m1();				(8)
		j=20[RW];				sop("First static block");	(10)
							
							}
				(3)	public static void main(String[] args){
						m1();			(13)
						sop("Main method");	(15)
						
					}
				(4)	public static void m1(){
						sop(j);					(9)(14)
					}
				(5)	static{
						sop("second static block");	(11)
					}
				(6)	static int j=20;				(12)
					
					
					}
				
				output: 
				------
					0
					First static block
					second static block
					20
					main method
					
					
		Read indirectly Write Only
		--------------------------
			Inside static block if we are trying to read a variable that read operation is called direct read
			If we are calling a method and within that method if we are trying to read a variable that read operation
			is called indirect read
				class Test{
					static int i =10;
					static{
						m1();
						sop(i) // direct read
						
					}
					static void m1(){
						sop(i) // indirect read
					}
				
				}
			If a variable is just identified by the JVM and original value is not yet assigned then the variable is said to
			be in read indirectly and write only state[RIWO]
			If a variable is in read indirectly write only state then we can't perform direct read but we can perform 
			indirect read
			If we are trying to read directly then we will get compile time error saying illegal forward reference
			
			Example 1:
				class Test{
				(1)	static int x =10; (3)
				(2)	static{			(4)
						sop(x);
					}	
					
				
				}
				output: 10
				runtime exception nosuchmethoderror : main
				
			Example 2:
				class Test{
				
				(1)	static{			(3)
						sop(x);
					}
					
				(2)	static int x =10; (4)
				}
				compile time error: illegal forward reference
				
			Example 3:
				class Test{
				
				(1)	static{			(4)
						m1();
					}
				(2)	public static void m1(){
						sop(x);
					}
					
				(3)	static int x =10; (5)
				}
				compile time error: illegal forward reference
				output: 0
				runtime exception nosuchmethoderror : main
				
	
	Date : 21-03-2016	
		
		static block
		------------
		
		static blocks will be executed at the time of class loading. Hence at the time of class loading if we want to perform 
		any activity we have to define that inside static block.
			Example1: At the time of java class loading the corresponding native libraries should be loaded. Hence we have
			to define this activity inside static block
				class Test{
					static{
						System.loadLibrary('native library path');
					}
				
				}
			
			Example2: After loading every database driver class we have to register driver class with driver manager. 
			But inside database driver class there is a static block to perform this activity and we are not responsible
			to register explicitily.
				class DbDriver{
					static{
						// register this driver with drivermanager
					}
				
				}
		Note: within a class we can declare any no.of static blocks but all these static blocks will be executed from top to
		bottom
		
		1. Without writing main() is it possible to print some statements to the console?
			Yes, By using static block
				class Test{
					static{
						sop("Hello i can print");
						System.exit(0);
						
					}
					
				}
		
		2. Without writing main method and static block is it possible to print some statements to the console?
			Yes, of couse there are multiple ways
			
			class Test{
				static int x = m1();
				
				public static int m1(){
					sop("Hello i can print");
					System.exit(0);
				}
			}
		
			class Test{
				static Test t = new Test();
				
				{
					sop("Hello i can print");
					System.exit(0);
				}
			}
			
			class Test{
				static Test t = new Test();
					
				Test(){
					sop("Hello i can print");
					System.exit(0);
				}
			}
			
		Note: From 1.7 version onwards main() is mandatory to start a program execution Hence from 1.7 version onwards without
		writing main() it is impossible to print some statements to the console
		 
		static control flow in Parent to child relationship:
		----------------------------------------------------
			Identification of static blocks from Parent to child
			Execute static variable assignments and static blocks from parent to child
			execute main method of child class
			
		
	Instance Control flow
	----------------------
		whenever we are executing java class first static control flow will be executed. In the static control flow if we
		are creating an object the following sequence of events will be executed as part of instance control flow
			1. Identification of instance members from top to bottom [2 to 8]
			2. Execution of instance variable assignments and instance blocks from top to bottom [9 to 14]
			3. Execution of constructor	[15]
			
				class Test{
		i =0[RIWO]	(3)		 int i =10;  (9)
		j=0[RIWO]		(4){
		i=10[RW];				m1();				(10)
		j=20[RW];				sop("First instance block");	(12)
							
							}
						(5)Test(){
							sop("constructor"); (15)
							
						}
				(1)	public static void main(String[] args){
					(2)	Test t = new Test();
						sop("Main ");	(16)
						
						}
				(6)	public  void m1(){
						sop(j);					(11)
					}
				(7)	{
						sop("second instance block");	(13)
					}
				(8)	 int j=20;				(14)
					
					
					}
			output:
			-------
				0
				First instance block
				second instance block
				constructor
				Main
			
				class Test{
					{
						sop("FIB");
					}
					static{
						sop("FSB");
					}
					Test(){
						sop("constructor");
					}
					public static void main(String[] args){
						Test t1 = new Test();
						sop("main");
						Test t2 = new Test();
					}
					static{
						sop("SSB");
					}
					{
						sop("SIB");
					}
				
				}
			
			output:
				FSB
				SSB
				FIB
				SIB
				constructor
				main
				FIB
				SIB
				constructor
	
			class Initialization{
				private static String m1(String msg){
					sop(msg);
					return msg;
				}
				public Initialization(){
					m = m1("1");
				}
				{
					m=m1("2");
				}
				String m = m1("3");
				public static void main(String[] args){
					Object o = new Initialization();
				}
			
			}
			output:
				2
				3
				1
				
			class Initialization2{
				private static String m1(String msg){
					sop(msg);
					return msg;
				}
				static String m =m1("1");
				{
					m=m1("2");
				}
				static{
					m = m1("3");
				}
				public static void main(String[] args){
					Object o = new Initialization();
				}
			
			}
			output:
				1
				3
				2
		
		**Note: From static area we can't access instance members directly because while executing static area JVM may not 
		identify instance members 
			class Test{
				int x =10;
				
				public static void main(String[] args){
				
					sop(x); compile time error: non-static variable cannot be referenced from a static context
				}
			
			}
		
		* In how many ways we can create an object in java?
				(or)
			In how many ways we can get object in java?
		
			1. By using new operator:
				Test t = new Test();
			
			2. By using newInstance():
				Test t = (Test)Class.forName("Test").newInstance();
			
			3. By using factory method:
				Runtime r = Runtime.getRuntime();
				DateFormat df = DateFormat.getInstance();
				
			4. By using clone method:
				Test t = new Test();
				Test t1 = t.clone();
			
			5. By using deserialization:
				FileInputStream fis = new FileInputStream("abc.ser");
				ObjectInputStream ois = new ObjectInputStream("fis");
				Test t = (Test)ois.readObject();
			
		
		
		Constructors:
		--------------
			Once we create an object compulsory we should perform initialization then only the object is in a position
			to respond properly
			Whenever we are creating an object some piece of the code will be executed automatically to perform 
			initialization of the object. This piece of the code is nothing but constructor. hence the main purpose of
			constructor is to perform initialization of an object
			
				class Student{
					String name;
					int rollNumber;
					Student(String name,int rollNumber){		----
						this.name = name;							| ---> Constructor
						this.rollNumber = rollNumber;				|
					}											----
					public static void main(String[] args){
						Student s1 = new Student("Durga",101);
						Student s2 = new Student("Ravi",102);
					}
				
				}
			Note: The main purpose of constructor is to perform initialization of an object not to create object
	
		Difference between constructor and instance block
		-------------------------------------------------
			The main purpose of constructor is to perform initialization of an object 
			but other than initialization if we want to perform any activity for every object creation then we should go for
			instance block(like updating one entry in the database for every object creation or incrementing count value for
			every object creation etc.,)
			Both constructor and instance block have their own different purposes and replacing one concept with another 
			concept may not work always
			both constructor and instance block will be executed for every object creation but instance block first 
			followed by constructor next
			
			Demo program to print no.of objects created for a class:
			
				class Test{
					static int count =0;
					{
						count++;
					}
					Test(){
					}
					Test(int i){
					
					}
					
					Test(double d){
					
					}
					
					public static void main(String[] args){
						Test t = new Test();
						Test t1 = new Test(10);
						Test t2 = new Test(10.5);
						sop("the no.of objects created "+count);
					
					}
				
				}
			Rules of writing constructors
			-----------------------------
				1. Name of the class and name of the constructor must be matched
				2. return type concept not applicable for constructor even void also
					by mistake if we are trying to declare return type for the constructor then we wont get any compile
					time error because compiler treats it as a method
				3. The only applicable modifiers for constructor are public, private, protected and default.
					If we are trying to use any other modifier we will get compile time error
		
		Compiler is responsible to generate default constructor (but not jvm)
		If we are not writing any constructor then only compiler will generate default constructor i.e., if we are writing 
		atleast one constructor then compiler wont generate default constructor. Hence every class in Java can contain constructor it may be default constructor generated by compiler or customized constructor explicitily provided
		by programmer but not both simultaneously
		
	
	Date: 22-03-2016
	-----------------
	
	Prototype of default constructor
	--------------------------------
		1. It is always no-arg constructor
		2. The access modifier of default constructor is exactly same as access modifier of class (This rule is applicable
			only for public and default modifiers)
		3. It contains only one line 
			Test(){
				super();
			}
			It is a no-argument call to super class constructor
		
		
		
					Programmer's code				|			compiler generated code
		------------------------------------------------------------------------------------------
			class Test{								|			class Test{
			}										|			 Test(){
													|				super();
													|				}
													|			}
		-----------------------------------------------------------------------------------------
			public class Test{						|			public class Test{
			}										|			 public Test(){
													|				super();
													|				}
													|			}
		-----------------------------------------------------------------------------------------
			public class Test{						|			public class Test{
				void Test(){}						|			 public Test(){
			}										|				super();
													|				}
													|			void Test(){}		
													|			}
		-----------------------------------------------------------------------------------------
													|
			class Test{								|			class Test{
				 Test(){}							|			 Test(){
			}										|				super();
													|				}
													|			}
		-----------------------------------------------------------------------------------------
													|
			class Test{								|			class Test{
				Test(int i){						|			 Test(int i){
				}									|				super();
			}										|				}
													|			}
		-----------------------------------------------------------------------------------------
													|
			class Test{								|			class Test{
				Test(){								|				Test(){
				this(10);							|				this(10)
				}									|			 }
				Test(int i){						|				Test(int i){
				}									|				super();
													|			}
													|			}
		-----------------------------------------------------------------------------------------
	
		
			The first line in every constructor should be either this() or super() and if we are not writing
			anything then compiler will always place super() 
				
		case 1:	
		-------
			we can take super() or this() only in first line of constructor. If we are trying to take anywhere else
			we will get compile time error
				class Test{
					Test(){
						sop("constructor");
						super();
					}
				
				}
				// compile time error: call to super must be first statement in constructor
		
		case 2:
		------
			within the constructor we can take either super() or this() but not both simultaneously
			
				class Test{
					Test(){
						super();
						this();
					}
					
				}
			// compile time error: call to this must be first statement in constructor
			
		case 3:
		-------
			we can use super() or this() only inside constructor. If we are trying to use outside of constructor
			we will get compile time error
				class Test{
					public void m1(){
						sop("m1 method");
						super();
					}
				
				}
			// compile time error: call to super must be first statement in constructor
			i.e., we can call a constructor directly from another constructor only
		
		
						-------------
						|			|--------> we can use only in constructors
						|	super()	| --------> only in first line
						|	this()	|
						|			|---------> only one can use not both simultaneously
						-------------
		
		
		
					super(),this()						|				super,this
			-----------------------------------------------------------------------------------------
			1. These are constructor calls to call		| These are keywords to refer super class and
				super class and current class 			| current class instance members
				constructors							|
			------------------------------------------------------------------------------------------
			2. We can use only in constructors 			|We can use anywhere except static area
				as first line							|
			-------------------------------------------------------------------------------------------
			3. We can use only once in constructor		| we can use any no.of times
			------------------------------------------------------------------------------------------
				
				class Test{
					public static void main(String[] args){
						sop(super.hashcode());
					}
				}
				// compiletime error: non-static variable static cannot be referenced from a static context
	
		
		
		Overloaded constructors
		-----------------------
			Within a class we can declare multiple constructors and all these constructors having same name but different
			type of arguments hence all these constructors are considered as overloaded constructors. hence overloading
			concept applicable for constructors
				
					class Test{
						Test(){
							this(10);
							sop("no-arg constructor");
						}
						Test(int i){
							this(10.5)
							soop("int-arg constructor");
						}
						Test(double d){
							sop("double constructor");
						}
						public static void main(String[] args){
						
							Test t = new Test();
											// double-arg constructor
											//int-arg constructor
											//no-arg constructor
							Test t1=new Test(10) 
											//int-arg constructor
											//double-arg constructor
							Test t2 = new Test(10.5) // double-arg constructor
							
							Test t3 = new Test(3.3f) //double-arg constructor
						
						}
					

					}
			
			For constructors inheritance and overriding concepts are not applicable but overloading concept is applicable
			Every class in java including abstract class can contain constructor but interface cannot contain constructor
			
				class Test{							abstract class Test{					interface Test{
				
					Test(){								Test(){									Test(){
					
					}									}										}
				
				}									}										}
				// valid							//valid									//Invalid
		
		
		Case1:
		------
			Recursive method call is a runtime exception saying stackoverflow error
			but in our program if there is a chance of recursive constructor invocation then the code won't compile and
			we will get compile time error
			
				class Test{														class Test{
					public static void m1(){										Test(){
						m2();															this(10);
					}																}
					public static void m2(){										Test(int i){
						m1();															this();
					}																}
					public static void main(String[] args){							public static void main(String[] args){
						m1();
						sop("hello");													sop("hello");
					}																}
				}																}
				runtime exception: stackoverflow error					compiletime exception: recursive constructor
			
			
			
		case 2:
		--------
			class P{								class P{								class P{
														P(){}									P(int i){}
			}										}										}
			
			class C extends P{						class C extends P{						class C extends P{
			
			}										}										}
			valid									valid									invalid
																							compileTimeError: cannont find
																							symbol constructor P() location 
																							class P
		Note:
			1.If parent class contains any argument constructor then while writing child classes we have to take special care
				w.r.t constructors
			*2. Whenever we are writing any argument constructor it is highly recommended to write no-arg constructor also
	
		
		case 3:
		-------
			class P{														class P{
				P() throws IOException{											P() throws IOException{
				
				}																}
			}																}	
			class C extends P{												class C extends P{
																				C() throws Exception{
			}																}
		compiletime error: java.io.IOException								//valid
		in default constructor
		
		If parent class constructor throws any checked exception compulsory child class constructor should throw
		the same checked exception or its parent otherwise the code wont compile
		
		
		Conclusion
		-----------
		1. The main purpose of constructor is to create an object //invalid
		2. The main purpose of constructor is initialize of  an object //valid
		3. The name of the constructor need not be same as class name // invalid
		4. Return type concept is applicable for constructors but only void //invalid
		5. we can apply any modifier for constructor //invalid
		6. Default constructor generated by JVM //invalid compiler is responsible to generate default constructor
		7. compiler will always generates default constructor //invalid
		8. If we are not writing no-arg constructor then compiler will generate default constructor //invalid
		9. Every no-arg constructor is always default constructor //invalid
		10.default constructor is always no-arg constructor //valid
		11.The first line inside every constructor should be either super() or this() if we are not writing anything then
			compiler will generates this() //invalid
		12.For constructors both overloading and overriding concepts are applicable //invalid
		13.For constructors inheritance concept applicable but not overriding //invalid
		14.Only concrete classes can contain constructor but abstract classes cannot // invalid
		15.Interface can contain constructors //invalid
		16.recursive constructor invocation is a runtime exception //invalid it is a compile time error
		17.If parent class constructor throws some checked exception then compulsory child class constructor should throw
			same checked exception or its child //invalid


		